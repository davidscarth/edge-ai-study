#version 450
// QX GEMM (Q4_0/Q8_0) - double-buffer + vec4(B)
const uint Q4_0_QK=32u, Q4_0_QS_WORDS=4u;
const uint Q8_0_QK=32u, Q8_0_QS_WORDS=8u;

layout (constant_id = 0) const uint QTYPE = 0u; // 0=Q4_0, 1=Q8_0
layout (constant_id = 1) const uint TM  = 64u;
layout (constant_id = 2) const uint TN  = 64u;
layout (constant_id = 3) const uint TK  = 16u;
layout (constant_id = 4) const uint tM  = 4u;
layout (constant_id = 5) const uint tN  = 4u;
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
const uint PAD_A=0u, PAD_B=0u;

layout(std430, binding=1) readonly  buffer Qs { uint qs[]; };
layout(std430, binding=2) readonly  buffer Bf { float b[]; };
layout(std430, binding=3) writeonly buffer Cf { float c[]; };
layout(std430, binding=4) readonly  buffer Sc { float sc[]; };
layout(std430, binding=9) readonly  buffer Bv4 { vec4 b4[]; };

layout(push_constant) uniform PC {
    uint M,N,K, ldb,ldc;
    uint off_q_e, off_s_e, off_b_e, off_c_e;
    uint blocks_per_row;
    uint flags; // bit0: B vec4 ok
} pc;

shared float As[2][TM][TK];
shared float Bs[2][TK][TN];

uint qs_byte_at(uint baseWord,uint byteIdx){
    uint w=qs[baseWord + (byteIdx>>2)];
    uint sh=(byteIdx & 3u)*8u; return (w>>sh)&0xFFu;
}
int sxt8(uint x){ return int(x<<24)>>24; }
int q8_sbyte(uint baseWord,uint byteIdx){
    uint w=qs[baseWord + (byteIdx>>2)]; uint sh=(byteIdx & 3u)*8u;
    return sxt8((w>>sh)&0xFFu);
}

float q4_0_unscaled(uint baseW,uint eib){
    uint byte_idx=eib>>1u; uint bv=qs_byte_at(baseW, byte_idx);
    bool hi=(eib & 1u)!=0u; uint nib= hi? ((bv>>4u)&0xFu) : (bv & 0xFu);
    return float(nib)-8.0;
}
float q8_0_unscaled(uint baseW,uint eib){ return float(q8_sbyte(baseW, eib)); }

void stageA(uint buf,uint k0){
    const uint lx=gl_LocalInvocationID.x, ly=gl_LocalInvocationID.y;
    const uint tileRow=gl_WorkGroupID.y*TM;
    const uint kChunk=min(TK, pc.K-k0);
    const uint QK=(QTYPE==0u)?Q4_0_QK:Q8_0_QK;
    const uint QS_WORDS=(QTYPE==0u)?Q4_0_QS_WORDS:Q8_0_QS_WORDS;
    for(uint i=ly;i<TM;i+=gl_WorkGroupSize.y){
        uint gRow=tileRow+i; bool ok=(gRow<pc.M);
        for(uint kk=lx; kk<kChunk; kk+=gl_WorkGroupSize.x){
            float aval=0.0; if(ok){
                uint gK=k0+kk; uint kblk=gK / QK; uint eib=gK - kblk*QK;
                uint blk=gRow*pc.blocks_per_row + kblk;
                uint qbase=pc.off_q_e + blk*QS_WORDS;
                float scale=sc[pc.off_s_e + blk];
                aval=(QTYPE==0u)? (scale*q4_0_unscaled(qbase,eib)) : (scale*q8_0_unscaled(qbase,eib));
            }
            As[buf][i][kk]=aval;
        }
    }
}

void stageB(uint buf,uint k0){
    const uint lx=gl_LocalInvocationID.x, ly=gl_LocalInvocationID.y;
    const uint tileCol=gl_WorkGroupID.x*TN;
    const uint kChunk=min(TK, pc.K-k0);
    for(uint kk=ly; kk<kChunk; kk+=gl_WorkGroupSize.y){
        uint gK=k0+kk; uint base=pc.off_b_e + gK*pc.ldb + tileCol;
        if((pc.flags&1u)!=0u){
            uint n4=TN>>2;
            for(uint j4=lx; j4<n4; j4+=gl_WorkGroupSize.x){
                vec4 v=vec4(0.0); uint gCol4=tileCol+j4*4u;
                if(gK<pc.K && (gCol4+3u)<pc.N) v=b4[(base>>2)+j4];
                uint j=j4*4u;
                Bs[buf][kk][j+0]=v.x; Bs[buf][kk][j+1]=v.y; Bs[buf][kk][j+2]=v.z; Bs[buf][kk][j+3]=v.w;
            }
            for(uint j=(TN&~3u)+lx; j<TN; j+=gl_WorkGroupSize.x){
                float bv=0.0; uint gCol=tileCol+j; if(gK<pc.K && gCol<pc.N) bv=b[base+j];
                Bs[buf][kk][j]=bv;
            }
        } else {
            for(uint j=lx; j<TN; j+=gl_WorkGroupSize.x){
                float bv=0.0; uint gCol=tileCol+j; if(gK<pc.K && gCol<pc.N) bv=b[base+j];
                Bs[buf][kk][j]=bv;
            }
        }
    }
}

void main(){
    const uint tileRow=gl_WorkGroupID.y*TM, tileCol=gl_WorkGroupID.x*TN;
    float acc[tM][tN]; for(uint i=0;i<tM;++i) for(uint j=0;j<tN;++j) acc[i][j]=0.0;
    uint buf=0u; stageA(buf,0u); stageB(buf,0u); barrier();
    for(uint k0=0u; k0<pc.K; k0+=TK){
        uint kChunk=min(TK, pc.K-k0);
        uint next=buf^1u; if(k0+TK<pc.K){ stageA(next,k0+TK); stageB(next,k0+TK);}
        const uint lx=gl_LocalInvocationID.x, ly=gl_LocalInvocationID.y, row0=ly*tM, col0=lx*tN;
        for(uint kk=0; kk<kChunk; ++kk){
            float aReg[tM], bReg[tN];
            for(uint i=0;i<tM;++i){ uint r=row0+i; aReg[i]=(r<TM)?As[buf][r][kk]:0.0;}
            for(uint j=0;j<tN;++j){ uint ccol=col0+j; bReg[j]=(ccol<TN)?Bs[buf][kk][ccol]:0.0;}
            for(uint i=0;i<tM;++i) for(uint j=0;j<tN;++j) acc[i][j]+=aReg[i]*bReg[j];
        }
        barrier(); buf=next;
    }
    const uint row0=gl_LocalInvocationID.y*tM, col0=gl_LocalInvocationID.x*tN;
    for(uint i=0;i<tM;++i){
        uint gRow=tileRow+row0+i; if(gRow>=pc.M) break;
        uint cBase=pc.off_c_e + gRow*pc.ldc + tileCol + col0;
        for(uint j=0;j<tN;++j){ uint gCol=tileCol+col0+j; if(gCol<pc.N) c[cBase+j]=acc[i][j]; }
    }
}
